C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  12          extern void Debug_txt_Tibbo(unsigned char * str);
  13          extern unsigned char  ValidaSensoresPaso(void);
  14          extern void send_portERR(unsigned char cod_err);
  15          extern void Debug_chr_Tibbo(unsigned char Dat);
  16          extern void Debug_HexDec(unsigned char xfc);
  17          extern char check_fechaOut(char *buffer);
  18          extern unsigned char Dir_board();
  19          extern void PantallaLCD(unsigned char cod_msg);
  20          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  21          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  23          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  24          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  25          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  26          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  27          
  28          sbit lock = P1^7;           //Relevo  
  29          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  30          sbit led_err_imp = P0^2;      //Error   
  31          /*variables externas*/
  32          
  33          extern unsigned char g_cEstadoComSoft;
  34          extern unsigned char ValTimeOutCom;
  35          extern unsigned char g_cEstadoComSeqMF;
  36          extern unsigned char g_cContByteRx;
  37          extern unsigned char xdata Buffer_Rta_Lintech[];
  38          extern int ID_CLIENTE;
  39          extern int COD_PARK;
  40          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  41          extern unsigned char Timer_wait;
  42          extern unsigned int  SIN_COBRO;
  43          /*externo bit*/
  44          
  45          extern bit buffer_ready;
  46          extern unsigned char USE_LPR;
  47          
  48          /*----------------------------------------------------------------------------
  49          Definiciones de sequencias de verificador y expedidor
  50          ------------------------------------------------------------------------------*/
  51          
  52          #define SEQ_INICIO            0X00  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 2   

  53          #define SEQ_CARD_INSERCION    0X01
  54          #define SEQ_CHECK_STATUS      0X02
  55          #define SEQ_RTA_CARD_POS      0x03
  56          #define SEQ_RTA_CAPTURE       0X04
  57          #define SEQ_REQUEST           0x05
  58          #define SEQ_MF_LINTECH        0x06
  59          #define SEQ_RD_S1B1           0x07
  60          #define SEQ_RD_S1B2           0x08
  61          #define SEQ_RD_S1B0           0x09
  62          #define SEQ_WR_S1B2           0x0a
  63          #define SEQ_RTA_S2B0          0x0b
  64          #define SEQ_RD_S1B0_EJECT     0x0c
  65          
  66          #define SEQ_EXPULSAR_TARJ     0x20
  67          #define SEQ_EXPULSAR_CHECK    0x21
  68          #define SEQ_EXPULSAR          0x22
  69          #define SEQ_EXPULSAR_FROM     0x23
  70          
  71          
  72          /*----------------------------------------------------------------------------
  73           definiciones de lintech en la inicializacion de expedidor o verificador
  74          ------------------------------------------------------------------------------*/
  75          
  76          #define INICIA_LINTECH          0x30
  77          #define SEQ_CAPTURE_DATOS_INI   0x31
  78          #define GRABA_EEPROM            0x32
  79          #define SEQ_CAPTURA_OK_EEPROM   0X33
  80          #define FIN_OK                  0x00
  81          
  82          /*----------------------------------------------------------------------------
  83           definiciones de lintech en el comando Check_Status
  84          ------------------------------------------------------------------------------*/
  85          
  86          #define S_DETAIL        0x31
  87          #define S_NORMAL        0x30
  88          
  89          /*------------------------------------------------------------------------------
  90           definiciones de lintech en el comando Card_Insercion
  91          ------------------------------------------------------------------------------*/
  92          
  93          #define Habilita        0x30
  94          #define Inhabilita      0x31
  95          
  96          /*------------------------------------------------------------------------------
  97          Definicion de Lintech en el comando Inicializa
  98          ------------------------------------------------------------------------------*/
  99          
 100          #define TO_FRONT        '0'
 101          #define CAPTURE_BOX     '1'
 102          #define SIN_MOVIMIENTO  '3'
 103          
 104          /*------------------------------------------------------------------------------
 105          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 106          ------------------------------------------------------------------------------*/
 107          
 108          #define   MovPos_Front        '0'   
 109          #define   MovPos_IC           '1'
 110          #define   MovPos_RF           '2'
 111          #define   MovPos_Capture      '3'
 112          #define   MovPos_EjectFront   '9'
 113          
 114          /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 3   

 115          Definicion de la trama Lintech de las respuestas de los cmd
 116          ------------------------------------------------------------------------------*/
 117          
 118          #define Pos_TipoResp        4
 119          #define Pos_Length          3
 120          #define Pos_St0             7
 121          #define Pos_St1             8
 122          #define Pos_St2             9
 123          #define Pos_IniDatMF        0x0a
 124          #define Card_type_H         0x0a
 125          #define Card_type_L         0x0b
 126          
 127          /*----------------------------------------------------------------------------
 128          definicion de recepcion serial 
 129          ------------------------------------------------------------------------------*/
 130          
 131          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 132          
 133          /*----------------------------------------------------------------------------
 134          tiempo de delay entre funciones
 135          ------------------------------------------------------------------------------*/
 136          
 137          #define   TIME_CARD         100   //50
 138          
 139          
 140          /*----------------------------------------------------------------------------
 141          definicion de datos de trama lintech
 142          ------------------------------------------------------------------------------*/
 143          
 144          #define   ETX               03
 145          #define   STX_LINTECH       0xf2
 146          
 147          /*----------------------------------------------------------------------------
 148          msj de lcd tarjeta y lcd serie
 149          ------------------------------------------------------------------------------*/
 150          
 151          #define ERROR_LOOP              0XE0
 152          #define TARJETA_INVALIDA        0XE1
 153          #define TARJETA_SIN_FORMATO     0xDF
 154          #define ERROR_COD_PARK          0XE5
 155          #define SIN_INGRESO             0XE6
 156          #define SIN_PAGO                0XE7
 157          #define EXCEDE_GRACIA           0XE8
 158          
 159          /*----------------------------------------------------------------------------
 160          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 161          ------------------------------------------------------------------------------*/
 162          
 163          #define   ENVIADOS          0X0
 164          #define   RESPUESTA         0X01
 165          
 166          /*----------------------------------------------------------------------------
 167          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 168          (0) si el dato es cero esta inactiva
 169          (1) activa o ROTACION
 170          
 171          ------------------------------------------------------------------------------*/
 172          
 173          #define INACTIVA          0x00
 174          #define ROTACION          0x01
 175          
 176          /*----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 4   

 177          posicion de  MF  bloque 1 sector 1
 178          (0) tipo de tarjeta 
 179          (01) el id del cliente
 180          (03)codigo del parqueadero  
 181          ------------------------------------------------------------------------------*/
 182          #define   MF_TIPO_TARJETA   0X00
 183          #define   MF_ID_CLIENTE     0x01
 184          #define   MF_COD_PARK       0x03
 185          
 186          /*----------------------------------------------------------------------------
 187          posicion de  MF bloque 2 sector 1
 188          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 189          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 190          ------------------------------------------------------------------------------*/
 191          
 192          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 193          
 194          
 195          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 196                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 197          #define   MF_LSB            0x06
 198          
 199          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 200          
 201          #define   MF_IN_PAGO        0x09
 202          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 203          
 204          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 205          
 206          /*----------------------------------------------------------------------------
 207          Definicion de varaibles globales del objeto
 208          ------------------------------------------------------------------------------*/
 209          
 210          static unsigned char Estado=INICIA_LINTECH;
 211          
 212          
 213          /*----------------------------------------------------------------------------
 214          funcion de inicializacion del transporte
 215          
 216          ------------------------------------------------------------------------------*/
 217          
 218          void Inicializa(unsigned char TipoMovimiento)
 219          {
 220   1        unsigned char j, bcc;
 221   1        unsigned char g_scArrTxComSoft[10];
 222   1        bcc=0;
 223   1        if ((TipoMovimiento==SIN_MOVIMIENTO)||(TipoMovimiento==TO_FRONT)||(TipoMovimiento==CAPTURE_BOX))
 224   1        {
 225   2          
 226   2          Debug_txt_Tibbo((unsigned char *) "Incializa Dispensador\r\n\r\n");
 227   2          
 228   2          g_scArrTxComSoft[0]=STX_LINTECH;
 229   2          g_scArrTxComSoft[1]=0X00;
 230   2          g_scArrTxComSoft[2]=0X00;
 231   2          g_scArrTxComSoft[3]=0X03;
 232   2          g_scArrTxComSoft[4]='C';
 233   2          g_scArrTxComSoft[5]='0';
 234   2          g_scArrTxComSoft[6]=TipoMovimiento;
 235   2          g_scArrTxComSoft[7]=ETX;
 236   2          for (j=0; j<8; j++)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 5   

 237   2          {
 238   3            bcc=g_scArrTxComSoft[j]^bcc;
 239   3          }
 240   2          g_scArrTxComSoft[8]=bcc;
 241   2          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 242   2          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 243   2          DebugBufferMF(g_scArrTxComSoft,9,0);                /*muestra la trama enviada al pto serie a debug por tibbo*/
 244   2          EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);    /* envio la trama por el pto serie*/
 245   2          ValTimeOutCom=TIME_CARD;
 246   2        }
 247   1      }
 248          
 249          /*------------------------------------------------------------------------------
 250          cmd de lintech que responde en que estado de los sensores se encuentra
 251          
 252          (30) solo envia el resumen de los sensores
 253          (31) da un reporte detallado de los sensores
 254          ------------------------------------------------------------------------------*/
 255          
 256          void Check_Status(unsigned char Detalle)
 257          {
 258   1        unsigned char j, bcc;
 259   1        unsigned char g_scArrTxComSoft[10];
 260   1        Debug_txt_Tibbo((unsigned char *) "Check_Status\r\n\r\n");
 261   1      
 262   1        bcc=0;
 263   1      
 264   1        g_scArrTxComSoft[0]=STX_LINTECH;
 265   1        g_scArrTxComSoft[1]=0X00;
 266   1        g_scArrTxComSoft[2]=0X00;
 267   1        g_scArrTxComSoft[3]=0X03;
 268   1        g_scArrTxComSoft[4]='C';
 269   1        g_scArrTxComSoft[5]='1';
 270   1        g_scArrTxComSoft[6]=Detalle;
 271   1        g_scArrTxComSoft[7]=ETX;
 272   1        for (j=0; j<8; j++)
 273   1        {
 274   2          bcc=g_scArrTxComSoft[j]^bcc;
 275   2        }
 276   1        g_scArrTxComSoft[8]=bcc;
 277   1        buffer_ready=0;
 278   1        g_cEstadoComSoft=ESPERA_RX;
 279   1        DebugBufferMF(g_scArrTxComSoft,9,0);
 280   1        EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);
 281   1        ValTimeOutCom=TIME_CARD;
 282   1      }
 283          
 284          /*------------------------------------------------------------------------------
 285          Procedimiento que habilita la insercion o inhabilita la insersion
 286          (31) inhabilita
 287          (30) habilita
 288          ------------------------------------------------------------------------------*/
 289          
 290          void Card_Insercion(char Tipo)
 291          {
 292   1        unsigned char j, bcc;
 293   1        unsigned char g_scArrTxComSoft[10];
 294   1        if (Tipo==Habilita)
 295   1        {
 296   2          Debug_txt_Tibbo((unsigned char *) "Habilita Insersion\r\n\r\n");
 297   2          g_scArrTxComSoft[6]=Habilita;
 298   2        }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 6   

 299   1        else
 300   1        {
 301   2          
 302   2          Debug_txt_Tibbo((unsigned char *) "Inhabilita Insersion\r\n\r\n");
 303   2          g_scArrTxComSoft[6]=Inhabilita;
 304   2        
 305   2        }
 306   1      
 307   1        bcc=0;
 308   1      
 309   1        g_scArrTxComSoft[0]=0xF2;
 310   1        g_scArrTxComSoft[1]=0X00;
 311   1        g_scArrTxComSoft[2]=0X00;
 312   1        g_scArrTxComSoft[3]=0X03;
 313   1        g_scArrTxComSoft[4]='C';
 314   1        g_scArrTxComSoft[5]='3';
 315   1      
 316   1        g_scArrTxComSoft[7]=ETX;
 317   1        for (j=0; j<8; j++)
 318   1        {
 319   2          bcc=g_scArrTxComSoft[j]^bcc;
 320   2        }
 321   1      
 322   1        g_scArrTxComSoft[8]=bcc;
 323   1      
 324   1        buffer_ready=0;
 325   1        g_cEstadoComSoft=ESPERA_RX;
 326   1        DebugBufferMF(g_scArrTxComSoft,9,0);
 327   1        EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);
 328   1        ValTimeOutCom=TIME_CARD;
 329   1      }
 330          
 331          /*------------------------------------------------------------------------------
 332          CMD q mueve la tarjeta 
 333          ------------------------------------------------------------------------------*/
 334          
 335          void Mov_Card(unsigned char Posicion)
 336          {
 337   1        unsigned char j, bcc;
 338   1        unsigned char g_scArrTxComSoft[10];
 339   1        bcc=0;
 340   1      
 341   1        if ((Posicion==MovPos_RF)||(Posicion==MovPos_IC)||(Posicion==MovPos_Front)||(Posicion==MovPos_EjectFront
             -)||(Posicion==MovPos_Capture))
 342   1        {
 343   2          if (Posicion==MovPos_RF)
 344   2          {
 345   3            Debug_txt_Tibbo((unsigned char *) "Moviendo Tarjeta a RF\r\n\r\n");
 346   3          }
 347   2          else if (Posicion==MovPos_IC)
 348   2          {
 349   3            Debug_txt_Tibbo((unsigned char *) "Moviendo Tarjeta a IC\r\n\r\n");
 350   3            }
 351   2          else if (Posicion==MovPos_Front)
 352   2          {
 353   3            Debug_txt_Tibbo((unsigned char *) "Moviendo Tarjeta a Bezel\r\n\r\n");
 354   3          }
 355   2          else if (Posicion==MovPos_EjectFront)
 356   2          {
 357   3            Debug_txt_Tibbo((unsigned char *) "Expulsando Tarjeta\r\n\r\n");
 358   3          }
 359   2          else if (Posicion==MovPos_Capture)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 7   

 360   2          {
 361   3            Debug_txt_Tibbo((unsigned char *) "Capturando Tarjeta\r\n\r\n");
 362   3          }
 363   2      
 364   2          g_scArrTxComSoft[0]=STX_LINTECH;
 365   2          g_scArrTxComSoft[1]=0X00;
 366   2          g_scArrTxComSoft[2]=0X00;
 367   2          g_scArrTxComSoft[3]=0X03;
 368   2          g_scArrTxComSoft[4]='C';
 369   2          g_scArrTxComSoft[5]='2';
 370   2          g_scArrTxComSoft[6]=Posicion;
 371   2          g_scArrTxComSoft[7]=ETX;
 372   2          for (j=0; j<8; j++)
 373   2          {
 374   3            bcc=g_scArrTxComSoft[j]^bcc;
 375   3          }
 376   2          g_scArrTxComSoft[8]=bcc;
 377   2          buffer_ready=0;
 378   2          g_cEstadoComSoft=ESPERA_RX;
 379   2          DebugBufferMF(g_scArrTxComSoft,9,0);
 380   2          EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);
 381   2          ValTimeOutCom=TIME_CARD;
 382   2        }
 383   1      
 384   1      }
 385          
 386          //*******************************************************************************************
 387          // rutina q mira el tipo de tarjeta si es valido para el uso  
 388          //*******************************************************************************************
 389          
 390          void Aut_Card_check_Status(void)
 391          {
 392   1      unsigned char j, bcc;
 393   1      unsigned char g_scArrTxComSoft[10];
 394   1            bcc=0;
 395   1        
 396   1        Debug_txt_Tibbo((unsigned char *) "Aut_Card_check_Status\r\n\r\n");
 397   1        
 398   1        g_scArrTxComSoft[0]=STX_LINTECH;
 399   1          g_scArrTxComSoft[1]=0X00;
 400   1          g_scArrTxComSoft[2]=0X00;
 401   1          g_scArrTxComSoft[3]=0X03;
 402   1          g_scArrTxComSoft[4]='C';
 403   1          g_scArrTxComSoft[5]=0x50;
 404   1          g_scArrTxComSoft[6]=0x31;
 405   1          g_scArrTxComSoft[7]=ETX;
 406   1            for (j=0; j<8; j++)
 407   1          {
 408   2            bcc=g_scArrTxComSoft[j]^bcc;
 409   2          }
 410   1          g_scArrTxComSoft[8]=bcc;
 411   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 412   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 413   1          DebugBufferMF(g_scArrTxComSoft,9,0);                /*muestra la trama enviada al pto serie a debug por tibbo*/
 414   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);    /* envio la trama por el pto serie*/
 415   1          ValTimeOutCom=TIME_CARD;
 416   1        } 
 417          
 418          /*------------------------------------------------------------------------------
 419          CMD q programa la clave en el verificador o transporte
 420          ------------------------------------------------------------------------------*/
 421          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 8   

 422            void Dwload_EEprom (void)
 423          {
 424   1        unsigned char j, bcc;
 425   1        unsigned char g_scArrTxComSoft[21];
 426   1        bcc=0;
 427   1        Debug_txt_Tibbo((unsigned char *) "Download MF EEprom\r\n\r\n");
 428   1        
 429   1        g_scArrTxComSoft[0]=0xF2;
 430   1        g_scArrTxComSoft[1]=0X00;
 431   1        g_scArrTxComSoft[2]=0X00;
 432   1        g_scArrTxComSoft[3]=0X0E;
 433   1        g_scArrTxComSoft[4]='C';
 434   1        g_scArrTxComSoft[5]=0x60;
 435   1        g_scArrTxComSoft[6]='3';
 436   1        g_scArrTxComSoft[7]=0x00;
 437   1        g_scArrTxComSoft[8]=0Xd0;
 438   1        g_scArrTxComSoft[9]=0X00;
 439   1        g_scArrTxComSoft[10]=0X01;
 440   1        g_scArrTxComSoft[11]=0x06;
 441   1        g_scArrTxComSoft[12]='3';
 442   1        g_scArrTxComSoft[13]='V';
 443   1        g_scArrTxComSoft[14]='0';
 444   1        g_scArrTxComSoft[15]='p';
 445   1        g_scArrTxComSoft[16]='4';
 446   1        g_scArrTxComSoft[17]='r';
 447   1        g_scArrTxComSoft[18]=ETX;
 448   1        
 449   1        for (j=0; j<19; j++)
 450   1          {
 451   2            bcc=g_scArrTxComSoft[j]^bcc;
 452   2          }
 453   1          g_scArrTxComSoft[19]=bcc;
 454   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 455   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 456   1          DebugBufferMF(g_scArrTxComSoft,20,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 457   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,20);   /* envio la trama por el pto serie*/
 458   1          ValTimeOutCom=TIME_CARD;
 459   1      }
 460          
 461          /*------------------------------------------------------------------------------
 462          Funcion q verifica si la clave y la carga en el transporte
 463          ------------------------------------------------------------------------------*/
 464          
 465          void LoadVerify_EEprom(void)
 466          {
 467   1        unsigned char j, bcc;
 468   1        unsigned char g_scArrTxComSoft[15];
 469   1        bcc=0;
 470   1        Debug_txt_Tibbo((unsigned char *) "Carga y Verifica de EEprom\r\n\r\n");
 471   1      
 472   1      
 473   1        g_scArrTxComSoft[0]=0xF2;
 474   1        g_scArrTxComSoft[1]=0X00;
 475   1        g_scArrTxComSoft[2]=0X00;
 476   1        g_scArrTxComSoft[3]=0X07;
 477   1        g_scArrTxComSoft[4]='C';
 478   1        g_scArrTxComSoft[5]=0x60;
 479   1        g_scArrTxComSoft[6]='3';
 480   1        g_scArrTxComSoft[7]=0x00;
 481   1        g_scArrTxComSoft[8]=0x21;
 482   1          g_scArrTxComSoft[9]=0x00;
 483   1        g_scArrTxComSoft[10]=0x01;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 9   

 484   1        g_scArrTxComSoft[11]=ETX;
 485   1        g_scArrTxComSoft[12]=0xc6;
 486   1      
 487   1        
 488   1      
 489   1        for (j=0; j<13; j++)
 490   1          {
 491   2            bcc=g_scArrTxComSoft[j]^bcc;
 492   2          }
 493   1          g_scArrTxComSoft[13]=bcc;
 494   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 495   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 496   1          DebugBufferMF(g_scArrTxComSoft,14,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 497   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,14);   /* envio la trama por el pto serie*/
 498   1          ValTimeOutCom=TIME_CARD;
 499   1          
 500   1      }
 501          
 502          /*------------------------------------------------------------------------------
 503          Funcion q lee la MF dandole el sector y el bloque
 504          ------------------------------------------------------------------------------*/
 505          
 506          void RD_MF(unsigned char Sector, unsigned char Bloque)
 507          {
 508   1      
 509   1        unsigned char j, bcc;
 510   1        unsigned char g_scArrTxComSoft[15];
 511   1        bcc=0;
 512   1      
 513   1        Debug_txt_Tibbo((unsigned char *) "Leyendo MF > Sector: ");
 514   1        Debug_chr_Tibbo(Sector);
 515   1        
 516   1        Debug_txt_Tibbo((unsigned char *) " Bloque: ");
 517   1        Debug_chr_Tibbo(Bloque);
 518   1        Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 519   1      
 520   1      
 521   1        g_scArrTxComSoft[0]=0xF2;
 522   1        g_scArrTxComSoft[1]=0X00;                   
 523   1        g_scArrTxComSoft[2]=0X00;
 524   1        g_scArrTxComSoft[3]=0X08;
 525   1        g_scArrTxComSoft[4]='C';
 526   1        g_scArrTxComSoft[5]=0X60;
 527   1        g_scArrTxComSoft[6]='3';
 528   1        g_scArrTxComSoft[7]=0x00;
 529   1        g_scArrTxComSoft[8]=0xb0;
 530   1        g_scArrTxComSoft[9]=Sector;
 531   1        g_scArrTxComSoft[10]=Bloque;
 532   1        g_scArrTxComSoft[11]=0x01;
 533   1        g_scArrTxComSoft[12]=ETX;
 534   1      
 535   1        for (j=0; j<13; j++)
 536   1        {
 537   2          bcc=g_scArrTxComSoft[j]^bcc;
 538   2        }
 539   1        g_scArrTxComSoft[13]=bcc;
 540   1      
 541   1      
 542   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 543   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 544   1          DebugBufferMF(g_scArrTxComSoft,14,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 545   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,14);   /* envio la trama por el pto serie*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 10  

 546   1          ValTimeOutCom=TIME_CARD;
 547   1      
 548   1      }
 549          
 550          /*------------------------------------------------------------------------------
 551          Funcion q lescribe la MF dandole el sector y el bloque y los datos
 552          ------------------------------------------------------------------------------*/
 553          
 554          
 555          void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer)     
 556             
 557          {
 558   1        unsigned char j, bcc;
 559   1        unsigned char g_scArrTxComSoft[31];
 560   1        bcc=0;
 561   1      
 562   1        Debug_txt_Tibbo((unsigned char *) "Escribe MF > Sector: ");
 563   1        Debug_chr_Tibbo(Sector);
 564   1        
 565   1        Debug_txt_Tibbo((unsigned char *) " Bloque: ");
 566   1        Debug_chr_Tibbo(Bloque);
 567   1        Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 568   1                                          
 569   1        g_scArrTxComSoft[0]=0xF2;
 570   1        g_scArrTxComSoft[1]=0X00;                   
 571   1        g_scArrTxComSoft[2]=0X00;
 572   1        g_scArrTxComSoft[3]=24;                                 /* Numero Datos a programar */ 
 573   1        
 574   1        g_scArrTxComSoft[4]='C';
 575   1        g_scArrTxComSoft[5]=0X60;
 576   1        g_scArrTxComSoft[6]='3';
 577   1        g_scArrTxComSoft[7]=0x00;
 578   1        g_scArrTxComSoft[8]=0xd1;
 579   1        g_scArrTxComSoft[9]=Sector;                             //Sector;
 580   1        g_scArrTxComSoft[10]=Bloque;                            //Bloque;
 581   1        g_scArrTxComSoft[11]=0x01;
 582   1      
 583   1        if(Sector!=2)
 584   1        { 
 585   2      /*------------------------------------------------------------------------------
 586   2      borro la fecha de entrada de entrada 
 587   2      ------------------------------------------------------------------------------*/
 588   2      
 589   2        g_scArrTxComSoft[12]=0x00;                              /*borro la fecha de entrada año mes dia hora minutos*/
 590   2        g_scArrTxComSoft[13]=0x00;
 591   2        g_scArrTxComSoft[14]=0x00;
 592   2        g_scArrTxComSoft[15]=0x00;
 593   2        g_scArrTxComSoft[16]=0x00;
 594   2      
 595   2      /*------------------------------------------------------------------------------
 596   2      borro los descuentos
 597   2      ------------------------------------------------------------------------------*/
 598   2        g_scArrTxComSoft[17]=0x00;
 599   2        g_scArrTxComSoft[18]=0x00;
 600   2        g_scArrTxComSoft[19]=0x00;
 601   2        
 602   2      /*------------------------------------------------------------------------------
 603   2      tipo de vehiculo
 604   2      ------------------------------------------------------------------------------*/
 605   2        
 606   2        g_scArrTxComSoft[20]=*buffer;
 607   2        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 11  

 608   2      /*------------------------------------------------------------------------------
 609   2      direccion de BOArd_pcb de salida o puerta de salida
 610   2      ------------------------------------------------------------------------------*/  
 611   2        g_scArrTxComSoft[21]=0x0f&Dir_board();
 612   2        
 613   2      /*------------------------------------------------------------------------------
 614   2      programo el APB como salida (02) entrada(01)
 615   2      ------------------------------------------------------------------------------*/
 616   2      g_scArrTxComSoft[22]=02;
 617   2      
 618   2      /*------------------------------------------------------------------------------
 619   2      borro la fecha de salida 
 620   2      ------------------------------------------------------------------------------*/
 621   2      
 622   2        g_scArrTxComSoft[23]=0x00;                              /*borro la fecha de entrada año mes dia hora minutos*/
 623   2        g_scArrTxComSoft[24]=0x00;
 624   2        g_scArrTxComSoft[25]=0x00;
 625   2        g_scArrTxComSoft[26]=0x00;
 626   2        g_scArrTxComSoft[27]=0x00;
 627   2      
 628   2        }
 629   1          else 
 630   1          {
 631   2            for (j=12; j<=28; j++)
 632   2            {
 633   3              g_scArrTxComSoft[j]=0x00; 
 634   3            }
 635   2          }
 636   1      
 637   1      
 638   1      
 639   1      
 640   1        g_scArrTxComSoft[28]=ETX;
 641   1        
 642   1        for (j=0; j<=28; j++)
 643   1        {
 644   2          bcc=bcc^g_scArrTxComSoft[j];
 645   2        }
 646   1        g_scArrTxComSoft[29]=bcc;
 647   1      
 648   1        
 649   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 650   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 651   1          DebugBufferMF(g_scArrTxComSoft,30,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 652   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,30);   /* envio la trama por el pto serie*/
 653   1          ValTimeOutCom=TIME_CARD;
 654   1        
 655   1      }
 656          
 657          /*------------------------------------------------------------------------------
 658          funcion que valida la trama del verificador o transporte lintech
 659          (0) significa que la trama es valida y sigue en el proceso
 660          (1) falla en la respuesta por pto serie o trama invalida
 661          (2) no ha recibido la trama del verificador o transporte
 662          (3) ERROR DE TRAMA CMD (N)
 663          ------------------------------------------------------------------------------*/
 664          
 665          char Trama_Validacion_P_N()
 666          {
 667   1        char Trama_Validacion_P_N=2;
 668   1        
 669   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 12  

 670   1            {
 671   2              if (buffer_ready==1)
 672   2              {
 673   3                buffer_ready=0;
 674   3                  
 675   3              
 676   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 677   3                {
 678   4                          
 679   4                  Trama_Validacion_P_N=0;
 680   4                    
 681   4                }
 682   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 683   3                {
 684   4                  
 685   4                  Trama_Validacion_P_N=3;
 686   4                  
 687   4                }
 688   3                else
 689   3                {
 690   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 691   4                  Trama_Validacion_P_N=3;   
 692   4                  
 693   4                }
 694   3              }
 695   2              else
 696   2              {
 697   3                          
 698   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 699   3                                                  
 700   3              }
 701   2      
 702   2            }
 703   1            
 704   1        return Trama_Validacion_P_N;
 705   1      }
 706          
 707          /*------------------------------------------------------------------------------
 708          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 709          
 710          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 711          ------------------------------------------------------------------------------*/
 712          
 713          unsigned char  Secuencia_inicio_expedidor(void)
 714          {
 715   1        char temp;
 716   1        switch (Estado)
 717   1        {
 718   2          case INICIA_LINTECH:
 719   2      
 720   2                
 721   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 722   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 723   2              
 724   2            
 725   2            return (Estado);
 726   2          break;
 727   2      
 728   2      
 729   2      /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 13  

 730   2      Envia la primera trama de inicializacion del transporte sin movimiento
 731   2            (0) LA RESPUESTA ES OK
 732   2            (1) NO RESPONDE EL PTO SERIE
 733   2            (2) NO RECIBIDO LA TRAMA 
 734   2            (3) ERROR DE TRAMA CMD (N)
 735   2      ------------------------------------------------------------------------------*/
 736   2            
 737   2          case SEQ_CAPTURE_DATOS_INI:
 738   2      
 739   2            if((temp=Trama_Validacion_P_N())!=0)
 740   2          {
 741   3            if(temp==2)
 742   3            {
 743   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 744   4            } 
 745   3            else if (temp==3)
 746   3            {
 747   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 748   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 749   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 750   4            }
 751   3            else
 752   3            {
 753   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 754   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 755   4            }
 756   3          }
 757   2          else
 758   2          {
 759   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 760   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 761   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 762   3          }     
 763   2          return (Estado);
 764   2          break;
 765   2            
 766   2      /*------------------------------------------------------------------------------
 767   2      Envia el cmd de grabar claves a la eeprom del transporte 
 768   2      ------------------------------------------------------------------------------*/
 769   2            
 770   2            case GRABA_EEPROM:
 771   2              
 772   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 773   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 774   2            
 775   2            
 776   2      
 777   2            return (Estado);
 778   2              break;
 779   2        
 780   2      /*------------------------------------------------------------------------------
 781   2      se analiza la respuesta 
 782   2            (0) LA RESPUESTA ES OK
 783   2            (1) NO RESPONDE EL PTO SERIE
 784   2            (2) NO RECIBIDO LA TRAMA 
 785   2            (3) ERROR DE TRAMA CMD (N)
 786   2      ------------------------------------------------------------------------------*/
 787   2            
 788   2          case SEQ_CAPTURA_OK_EEPROM:
 789   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 14  

 790   2          if((temp=Trama_Validacion_P_N())!=0)
 791   2          {
 792   3            if(temp==2)
 793   3            {
 794   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 795   4            }
 796   3            else if (temp==3)
 797   3            {
 798   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 799   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 800   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 801   4            }     
 802   3            else
 803   3            {
 804   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 805   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 806   4            }       
 807   3          }
 808   2          else
 809   2          {
 810   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 811   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 812   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 813   3          }     
 814   2      
 815   2          return (Estado);
 816   2          break;
 817   2      
 818   2      /*------------------------------------------------------------------------------
 819   2      Fin de la secuencia de comandos con exito 
 820   2      ------------------------------------------------------------------------------*/    
 821   2            
 822   2              case FIN_OK:
 823   2      
 824   2              return (Estado);
 825   2          break;
 826   2            
 827   2                
 828   2              default:
 829   2              return Estado=INICIA_LINTECH; 
 830   2              break;
 831   2        }
 832   1      }
 833          
 834          /*------------------------------------------------------------------------------
 835          Prosedimiento  q hace paso a paso la secuencia de la MF
 836          ------------------------------------------------------------------------------*/
 837          
 838          void SecuenciaExpedidor(void)
 839          {
 840   1        unsigned char temp;
 841   1        static unsigned char buffer_S1_B0[17];
 842   1        static unsigned char buffer_S1_B1[17];
 843   1        static unsigned char buffer_S1_B2[17];
 844   1        static unsigned char error_rx=0; 
 845   1        unsigned char clock_temp[6];
 846   1        switch (g_cEstadoComSeqMF)
 847   1        {
 848   2      //***********************************************************************************************
 849   2          
 850   2          case SEQ_INICIO:
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 15  

 851   2      
 852   2            if (ValTimeOutCom==1)
 853   2            {
 854   3      
 855   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
 856   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
 857   3              
 858   3            }
 859   2       
 860   2          break;
 861   2      
 862   2      /*------------------------------------------------------------------------------
 863   2      Analizo la trama de insercion por boca
 864   2            (0) LA RESPUESTA ES OK
 865   2            (1) NO RESPONDE EL PTO SERIE
 866   2            (2) NO RECIBIDO LA TRAMA 
 867   2            (3) ERROR DE TRAMA CMD (N)
 868   2      ------------------------------------------------------------------------------*/      
 869   2          
 870   2          case SEQ_CARD_INSERCION:  
 871   2            
 872   2          if((temp=Trama_Validacion_P_N())!=0)
 873   2          {
 874   3            if(temp==2)
 875   3            {
 876   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
 877   4            } 
 878   3            else if (temp==3)
 879   3            {
 880   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
 881   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 882   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
 883   4            }     
 884   3            else
 885   3            {
 886   4            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 887   4              if (error_rx>= 3)
 888   4              {
 889   5                error_rx=0;
 890   5                Atascado=1;                                                                           /*apago el verificador*/
 891   5                led_err_imp=0;                                                                        /*error led on*/
 892   5                Timer_wait=0;
 893   5                ValTimeOutCom=3;        
 894   5                g_cEstadoComSeqMF=SEQ_INICIO;     //SEQ_CHECK_STATUS;
 895   5                  break;                                                                              /* respuesta incorrecta*/ 
 896   5              }     
 897   4      
 898   4              error_rx++;
 899   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                       /* respuesta incorrecta*/ 
 900   4            }       
 901   3          }
 902   2          else
 903   2          {
 904   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
 905   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 906   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
 907   3          }     
 908   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 16  

 909   2          break;
 910   2            
 911   2      /*------------------------------------------------------------------------------
 912   2      chequeo el estado de los sensores 
 913   2      ------------------------------------------------------------------------------*/      
 914   2          
 915   2          case SEQ_CHECK_STATUS:  
 916   2                      
 917   2              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
 918   2              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
 919   2             
 920   2            break;      
 921   2              
 922   2      /*------------------------------------------------------------------------------
 923   2      Valido la informacion de los sensores
 924   2            (0) LA RESPUESTA ES OK
 925   2            (1) NO RESPONDE EL PTO SERIE
 926   2            (2) NO RECIBIDO LA TRAMA 
 927   2            (3) ERROR DE TRAMA CMD (N)
 928   2      ------------------------------------------------------------------------------*/    
 929   2      
 930   2          case SEQ_RTA_CARD_POS:
 931   2            
 932   2          if((temp=Trama_Validacion_P_N())!=0)
 933   2          {
 934   3            if(temp==2)
 935   3            {
 936   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
 937   4            } 
 938   3            else if (temp==3)
 939   3            {
 940   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n\r\n");                     /* trama no valida*/
 941   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
 942   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
 943   4            }     
 944   3            else
 945   3            {
 946   4            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 947   4              if (error_rx>= 3)
 948   4              {
 949   5                error_rx=0;
 950   5                Atascado=1;                                                                           /*apago el verificador*/
 951   5                led_err_imp=0;                                                                        /*error led on*/
 952   5                Timer_wait=0;
 953   5                ValTimeOutCom=3;        
 954   5                g_cEstadoComSeqMF=SEQ_INICIO;     //SEQ_CHECK_STATUS;
 955   5                  break;                                                                              /* respuesta incorrecta*/ 
 956   5              } 
 957   4              error_rx++;
 958   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
 959   4            }     
 960   3          }
 961   2          else
 962   2          {
 963   3            Debug_txt_Tibbo((unsigned char *) "CHECK SATUS OK\r\n\r\n");                                  /* trama valida Habilitado
             - */
 964   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
 965   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
             - el mecanismo*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 17  

 966   3                  {
 967   4                    
 968   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n\r\n");       /* trama valida 
             -Habilitado insercion por boca*/
 969   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
 970   4      
 971   4                    
 972   4                  }
 973   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
 974   3                  {
 975   4                    
 976   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n\r\n");                      /* trama valida Habilita
             -do insercion por boca*/
 977   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
 978   4                                           
 979   4                  }
 980   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
 981   3                  {
 982   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n\r\n");             /* trama valida H
             -abilitado insercion por boca*/
 983   4                                
 984   4                    error_rx=0;
 985   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 986   4                    {
 987   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n\r\n");                   /* se encuentra un senso
             -r activo*/
 988   5                    Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF50*
             -/
 989   5                    g_cEstadoComSeqMF=SEQ_REQUEST;                                                      /*vamos al siguiente paso a con validar el
             - cmd*/    
 990   5                    }
 991   4                    else
 992   4                    {
 993   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n\r\n");              /* no hay vehiculo en e
             -l loop*/
 994   5                      send_portERR(ERROR_LOOP);                                                         /*envio msj al lcd tarjeta*/
 995   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
 996   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
 997   5                      
 998   5                    }
 999   4                                                                  
1000   4                  }
1001   3                                                                    
1002   3          }     
1003   2            
1004   2          break;
1005   2        
1006   2      /*------------------------------------------------------------------------------
1007   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1008   2            (0) LA RESPUESTA ES OK
1009   2            (1) NO RESPONDE EL PTO SERIE
1010   2            (2) NO RECIBIDO LA TRAMA 
1011   2            (3) ERROR DE TRAMA CMD (N)
1012   2      ------------------------------------------------------------------------------*/  
1013   2      
1014   2        case SEQ_RTA_CAPTURE:
1015   2          
1016   2          if((temp=Trama_Validacion_P_N())!=0)
1017   2          {
1018   3            if(temp==2)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 18  

1019   3            {
1020   4                
1021   4            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;                                                    /*no ha respondido*/
1022   4          
1023   4            } 
1024   3              else if (temp==3)
1025   3            {
1026   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n\r\n");                   /* Tama incorrecta no ejec
             -ta la tarjeta*/
1027   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1028   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1029   4            } 
1030   3            else
1031   3            {
1032   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n"); /* respuesta incor
             -recta*/  
1033   4              g_cEstadoComSeqMF=SEQ_INICIO; 
1034   4            
1035   4            }       
1036   3          }
1037   2          else
1038   2          {
1039   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1040   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1041   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok inicia revisando sensores*/
1042   3          }     
1043   2            
1044   2      
1045   2          break;  
1046   2      /*------------------------------------------------------------------------------
1047   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
1048   2      (1 0)  es una tarjeta valida Mf50 
1049   2      las demas combinaciones son tomadas como no validas
1050   2            (0) LA RESPUESTA ES OK
1051   2            (1) NO RESPONDE EL PTO SERIE
1052   2            (2) NO RECIBIDO LA TRAMA 
1053   2            (3) ERROR DE TRAMA CMD (N)    
1054   2      ------------------------------------------------------------------------------*/  
1055   2      
1056   2        case SEQ_REQUEST:
1057   2          
1058   2        if((temp=Trama_Validacion_P_N())!=0)
1059   2          {
1060   3            if(temp==2)
1061   3            {
1062   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
1063   4            } 
1064   3              else if (temp==3)
1065   3            {
1066   4              
1067   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n\r\n");                       /* trama no valida*/
1068   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
1069   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
1070   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
1071   4            } 
1072   3            else
1073   3            {
1074   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n\r\n");      /* pto serie no
             - responde*/
1075   4              send_portERR(TARJETA_INVALIDA);                                                           /*la tarjeta no es valida no la puede i
             -dentificar*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 19  

1076   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1077   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
1078   4            
1079   4            }       
1080   3          }
1081   2          else
1082   2          {
1083   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
1084   3                    {
1085   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
1086   4                        {
1087   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
1088   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
1089   5                          LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tran
             -sporte
1090   5                          g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
1091   5                          
1092   5                       }else
1093   4                        {
1094   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
1095   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
1096   5                        send_portERR(TARJETA_INVALIDA);
1097   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1098   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
1099   5                         
1100   5                        }
1101   4                   }
1102   3                    else 
1103   3                    {
1104   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
1105   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
1106   4                    send_portERR(TARJETA_INVALIDA);                                                     //la tarjeta no es valida 
1107   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1108   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
1109   4                  
1110   4                    }
1111   3                                                                                                            /*respuesta ok inicia revisando sensores*/
1112   3          }     
1113   2                
1114   2            break;
1115   2      /*------------------------------------------------------------------------------
1116   2      Verifica la eeprom 
1117   2            (0) LA RESPUESTA ES OK
1118   2            (1) NO RESPONDE EL PTO SERIE
1119   2            (2) NO RECIBIDO LA TRAMA 
1120   2            (3) ERROR DE TRAMA CMD (N)
1121   2      ------------------------------------------------------------------------------*/  
1122   2        case SEQ_MF_LINTECH:
1123   2          
1124   2        if((temp=Trama_Validacion_P_N())!=0)
1125   2          {
1126   3            if(temp==2)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 20  

1127   3            {
1128   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
1129   4            }
1130   3            else if (temp==3)
1131   3            {
1132   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
1133   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1134   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1135   4            }       
1136   3            else
1137   3            { 
1138   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1139   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
1140   4            }
1141   3          }
1142   2          else
1143   2          {
1144   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n\r\n");                       /* trama OK CARGA LA EEP
             -ROM Y LA VERIFICA*/
1145   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1146   3            RD_MF(1,1);                                                                               /*leo MF */
1147   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
1148   3          }     
1149   2      
1150   2        
1151   2        break;
1152   2      /*------------------------------------------------------------------------------
1153   2      Leo la Mf en el sector 1  bloque 1
1154   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1155   2      ------------------------------------------------------------------------------*/      
1156   2        
1157   2        case SEQ_RD_S1B1:
1158   2          
1159   2      if((temp=Trama_Validacion_P_N())!=0)
1160   2          {
1161   3            if(temp==2)
1162   3            {
1163   4            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*no ha respondido*/
1164   4            }
1165   3            else if (temp==3)
1166   3            {
1167   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1168   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1169   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1170   4            }       
1171   3            else
1172   3            { 
1173   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1174   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1175   4            }
1176   3          }
1177   2          else
1178   2          {
1179   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n\r\n");                              /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1180   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 21  

1181   3            
1182   3            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1183   3            {
1184   4              
1185   4                for (temp=0; temp<16; temp++)
1186   4                {
1187   5                  buffer_S1_B1[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de 
             -MF en un arreglo*/
1188   5                }
1189   4                if (((buffer_S1_B1[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S1_B1[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE=
             -=0)&&(COD_PARK==0)))    
1190   4                {
1191   5                    
1192   5                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
1193   5                  Debug_HexDec(buffer_S1_B1[MF_ID_CLIENTE]);
1194   5                  Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1195   5                  
1196   5                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
1197   5                  Debug_HexDec(buffer_S1_B1[MF_COD_PARK]);
1198   5                  Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1199   5      
1200   5      
1201   5                  
1202   5                  if  ((buffer_S1_B1[MF_TIPO_TARJETA]==ROTACION))         
1203   5                  {
1204   6                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA 1 ROTACION: ");
1205   6                    Debug_chr_Tibbo(buffer_S1_B1[MF_TIPO_TARJETA]);
1206   6                    Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1207   6                    
1208   6                    RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
1209   6                    g_cEstadoComSeqMF=SEQ_RD_S1B2;
1210   6                    
1211   6                  }
1212   5                  else 
1213   5                  {
1214   6                    send_portERR(TARJETA_INVALIDA);
1215   6                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1216   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* expulso la tarjeta */    
1217   6                  }
1218   5                }
1219   4                else
1220   4                {
1221   5                  send_portERR(ERROR_COD_PARK);
1222   5                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
1223   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* codigo de parqueo erro expulso la tar
             -jeta */    
1224   5                }
1225   4            }
1226   3            else
1227   3            {
1228   4              send_portERR(TARJETA_SIN_FORMATO);
1229   4              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
1230   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1231   4            }
1232   3            
1233   3          }     
1234   2        break;
1235   2      /*------------------------------------------------------------------------------
1236   2      Leo la Mf en el  sector 1 bloque 2
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 22  

1237   2        Se lee Fecha in, fecha out
1238   2      ------------------------------------------------------------------------------*/
1239   2        case SEQ_RD_S1B2:
1240   2              
1241   2        if((temp=Trama_Validacion_P_N())!=0)
1242   2          {
1243   3            if(temp==2)
1244   3            {
1245   4            g_cEstadoComSeqMF=SEQ_RD_S1B2;                                                            /*no ha respondido*/
1246   4            }
1247   3            else if (temp==3)
1248   3            {
1249   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1250   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1251   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1252   4            }       
1253   3            else
1254   3            { 
1255   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1256   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1257   4            }
1258   3          }
1259   2          else
1260   2          {
1261   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n\r\n");                              /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1262   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1263   3            for (temp=0; temp<16; temp++)
1264   3            {
1265   4              buffer_S1_B2[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de M
             -F en un arreglo*/
1266   4            }
1267   3            
1268   3            if((buffer_S1_B2[MF_APB]==02)||(buffer_S1_B2[MF_APB]==0) )                              /*Pregunto por el antipasban s
             -i es 02 ya salio y no posee entrada*/
1269   3            {                                                                                                             /*00 inhabilitada la tarjeta*/
1270   4            Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n\r\n");
1271   4            send_portERR(SIN_INGRESO);
1272   4            PantallaLCD(SIN_INGRESO);
1273   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1274   4              break;
1275   4            }
1276   3            
1277   3            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
1278   3            {
1279   4              if (SIN_COBRO==1)
1280   4              {
1281   5                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1282   5                RD_MF(1, 0);                                                                                                /* Leo el ticket */
1283   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
1284   5                break;
1285   5              }
1286   4              else if( SIN_COBRO ==2)
1287   4              {
1288   5                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
1289   5                        
1290   5          
1291   5                if ((buffer_S1_B2[0]==clock_temp[0])&&(buffer_S1_B2[1]==clock_temp[1])&&(buffer_S1_B2[2]==clock_temp[
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 23  

             -2]))    /*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1292   5                {
1293   6                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1294   6                  RD_MF(1, 0);                                                                                              /* Leo el ticket */
1295   6                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1296   6                  break;
1297   6                }                                                                                         
1298   5                  else
1299   5                  {
1300   6                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");                                             /*excede el time
             -po de gracia del dia */
1301   6                  send_portERR(EXCEDE_GRACIA);
1302   6                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1303   6                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1304   6                  break;              
1305   6                  }
1306   5                
1307   5                
1308   5              }
1309   4            }
1310   3          
1311   3            
1312   3            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1313   3            {
1314   4              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1315   4              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1316   4              Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");    
1317   4              analiza_tiempo(buffer_S1_B2,T_GRACIA);                                                // Simula Fecha Max de Salida.
1318   4            
1319   4            }
1320   3            
1321   3            temp=check_fechaOut(buffer_S1_B2+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1322   3              if(temp==1)
1323   3              {
1324   4                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n\r\n");
1325   4                  send_portERR(SIN_PAGO);
1326   4                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
             -y*/
1327   4                  RD_MF(1, 0);                                                                      /**leo el ticket*/  
1328   4                  g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;          
1329   4                              
1330   4              }
1331   3              else if (temp==2)
1332   3              {
1333   4                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1334   4                send_portERR(EXCEDE_GRACIA);
1335   4                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1336   4                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;  
1337   4              }
1338   3              else
1339   3              {
1340   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1341   4                RD_MF(1, 0);                                                                      /* Leo el ticket */
1342   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1343   4              }
1344   3            
1345   3          }
1346   2        
1347   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 24  

1348   2            
1349   2            
1350   2        break;
1351   2      
1352   2      /*------------------------------------------------------------------------------
1353   2      Leo la Mf en el  sector 1 bloque 0
1354   2          lee el ticket
1355   2      ------------------------------------------------------------------------------*/    
1356   2          
1357   2        case SEQ_RD_S1B0:
1358   2        
1359   2        if((temp=Trama_Validacion_P_N())!=0)
1360   2          {
1361   3            if(temp==2)
1362   3            {
1363   4            g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                            /*no ha respondido*/
1364   4            }
1365   3            else if (temp==3)
1366   3            {
1367   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el leer el bloque*/
1368   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1369   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1370   4            }       
1371   3            else
1372   3            { 
1373   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1374   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1375   4            }
1376   3          }
1377   2          else
1378   2          {
1379   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1380   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1381   3            
1382   3        for (temp=0; temp<16; temp++)
1383   3            {
1384   4              
1385   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1386   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1387   4              {
1388   5                break;
1389   5              }
1390   4            }
1391   3            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
1392   3            Debug_txt_Tibbo(buffer_S1_B0);
1393   3            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1394   3            
1395   3            lock=1;   
1396   3            Timer_wait=0;                                                                               /*activo la barrera*/
1397   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S1_B2,'s');                                      /*transmito pto paralelo*/
1398   3            if(USE_LPR)
1399   3            {
1400   4              Cmd_LPR_Salida(buffer_S1_B0,buffer_S1_B2);                                                /*envio datos a Monitor*/
1401   4            }
1402   3            
1403   3            WR_MF(1, 2,buffer_S1_B2+MF_TIPO_VEHICULO);
1404   3            g_cEstadoComSeqMF=SEQ_WR_S1B2;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 25  

1405   3          }
1406   2        break;
1407   2        
1408   2        case SEQ_WR_S1B2:
1409   2          if((temp=Trama_Validacion_P_N())!=0)
1410   2          {
1411   3            if(temp==2)
1412   3            {
1413   4            g_cEstadoComSeqMF=SEQ_WR_S1B2;                                                            /*no ha respondido*/
1414   4            }
1415   3            else if (temp==3)
1416   3            {
1417   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1418   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1419   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1420   4            }       
1421   3            else
1422   3            { 
1423   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1424   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1425   4            }
1426   3          }
1427   2          else
1428   2          {
1429   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1430   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1431   3            WR_MF(2, 0,buffer_S1_B2+MF_TIPO_VEHICULO);
1432   3            g_cEstadoComSeqMF=SEQ_RTA_S2B0; 
1433   3          }
1434   2          break;
1435   2        
1436   2        case SEQ_RTA_S2B0:
1437   2      
1438   2        if((temp=Trama_Validacion_P_N())!=0)
1439   2          {
1440   3            if(temp==2)
1441   3            {
1442   4            g_cEstadoComSeqMF=SEQ_RTA_S2B0;                                                           /*no ha respondido*/
1443   4            }
1444   3            else if (temp==3)
1445   3            {
1446   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n\r\n");                            /* trama no valida respue
             -sta incorrecta el leer el bloque*/
1447   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1448   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1449   4            }       
1450   3            else
1451   3            { 
1452   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1453   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1454   4            }
1455   3          }
1456   2          else
1457   2          {
1458   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n\r\n");                             /* trama OK CARGA numero de
             - ticket*/
1459   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 26  

             -    
1460   3            
1461   3      
1462   3        
1463   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n\r\n");                              /* pto serie no responde*/
1464   3            Mov_Card(MovPos_Capture);
1465   3            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1466   3          }
1467   2          break;
1468   2      /*------------------------------------------------------------------------------
1469   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1470   2      LA tarjeta no tiene pago    
1471   2        
1472   2      ------------------------------------------------------------------------------*/
1473   2        
1474   2        
1475   2        case SEQ_RD_S1B0_EJECT: 
1476   2          
1477   2          if((temp=Trama_Validacion_P_N())!=0)
1478   2          {
1479   3            if(temp==2)
1480   3            {
1481   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;                                                            /*no ha respondido*/
1482   4            }
1483   3            else if (temp==3)
1484   3            {
1485   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el leer el bloque*/
1486   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1487   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1488   4            }       
1489   3            else
1490   3            { 
1491   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1492   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1493   4            }
1494   3          }
1495   2          else
1496   2          {
1497   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n\r\n");                              /* trama OK CARGA nume
             -ro de ticket*/
1498   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1499   3            
1500   3        for (temp=0; temp<16; temp++)
1501   3            {
1502   4              
1503   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1504   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1505   4              {
1506   5                break;
1507   5              }
1508   4            }
1509   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S1_B2,'P');    
1510   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
1511   3          } 
1512   2            break;
1513   2        
1514   2      /*------------------------------------------------------------------------------
1515   2      expulsa la tarjeta por que no pertenece a MF50
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 27  

1516   2      ------------------------------------------------------------------------------*/    
1517   2        
1518   2        case SEQ_EXPULSAR_TARJ:
1519   2            Card_Insercion(Inhabilita); 
1520   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
1521   2        break;
1522   2        
1523   2        
1524   2        case SEQ_EXPULSAR_CHECK:
1525   2        if((temp=Trama_Validacion_P_N())!=0)
1526   2          {
1527   3            if(temp==2)
1528   3            {
1529   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
1530   4            } 
1531   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1532   3          }
1533   2          else
1534   2          {
1535   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
1536   3          }   
1537   2          
1538   2          break;
1539   2          
1540   2        case SEQ_EXPULSAR:
1541   2          Mov_Card(MovPos_EjectFront);
1542   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
1543   2        
1544   2        case SEQ_EXPULSAR_FROM:                       
1545   2          if((temp=Trama_Validacion_P_N())!=0)
1546   2          {
1547   3            if(temp==2)
1548   3            {
1549   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
1550   4            } 
1551   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1552   3          }
1553   2          else
1554   2          {
1555   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
1556   3          }   
1557   2          
1558   2        break;
1559   2        
1560   2      /*------------------------------------------------------------------------------
1561   2      expulsa la tarjeta por que no pertenece a MF50
1562   2      ------------------------------------------------------------------------------*/      
1563   2          
1564   2              default:
1565   2              g_cEstadoComSeqMF=SEQ_INICIO; 
1566   2              break;  
1567   2            
1568   2        } 
1569   1      }
1570          
1571          
1572            


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       06/06/2019 12:32:48 PAGE 28  

   CODE SIZE        =   4405    ----
   CONSTANT SIZE    =   1426    ----
   XDATA SIZE       =     53     158
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
